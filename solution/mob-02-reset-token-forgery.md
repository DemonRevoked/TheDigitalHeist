# mob-02 — Walkthrough (Offline Reset Token Forgery APK)

## Goal
Install the APK, then recover **both** values shown only after authorization:
- **KEY**: the per-startup challenge key (generated by the platform)
- **FLAG**: `TDHCTF{...}`

This challenge is **offline-only** (no server).

## Key insight
The app accepts a password-reset “token” that is a **JWT**.  
Because the app verifies JWTs **locally**, the signing secret must also be inside the APK.

If you extract the **JWT signing secret**, you can forge your own token with `role=admin` and the app will reveal the KEY + FLAG.

## Steps

### 1) Generate a sample token in the app
Open the APK and use **Generate reset token** for any email.  
You will see a token that looks like:

- `header.payload.signature`

That’s a JWT.

### 2) Decompile the APK
Use `jadx`:
- Open the APK
- Search for keywords:
  - `HmacSHA256`
  - `HS256`
  - `jwtSecret`
  - `SecretProvider`

You should find a class like:
- `SecretProvider`

Inside it, the JWT signing secret is constructed from string parts (still fully recoverable).

### 3) Extract the signing secret
Recover the full secret string that the app uses to sign/verify tokens.

This secret is **not** the challenge KEY.  
It is only the JWT signing key used to verify reset tokens.

**JWT signing secret (as shipped):**
- `TDH_MOB03_RESET_TOKEN_SIGNING_KEY_2025`

### 4) Forge an admin JWT (HS256)
Create a new JWT with:
- `alg`: `HS256`
- Payload includes:
  - `email`: any string
  - `role`: `admin`
  - `exp`: a future UNIX timestamp (seconds)

Then sign it with **HS256 using the extracted secret**.

Example Python (offline):

```python
import base64, hmac, hashlib, json, time

def b64url(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).decode().rstrip("=")

secret = b"TDH_MOB03_RESET_TOKEN_SIGNING_KEY_2025"

header = {"alg": "HS256", "typ": "JWT"}
now = int(time.time())
payload = {
    "email": "test@ctf.local",
    "role": "admin",
    "iat": now,
    "exp": now + 3600,
}

header_b64 = b64url(json.dumps(header, separators=(",", ":")).encode())
payload_b64 = b64url(json.dumps(payload, separators=(",", ":")).encode())
signing_input = f"{header_b64}.{payload_b64}".encode()
sig = hmac.new(secret, signing_input, hashlib.sha256).digest()

token = f"{header_b64}.{payload_b64}.{b64url(sig)}"
print(token)
```

### 5) Submit the forged token to the app
Paste the forged token into the **Submit token** section and tap **Reset**.

If valid, the app displays:
- **KEY**
- **FLAG**

## Notes (for why this works)
The app makes an authorization decision (“admin or not”) purely on the client.  
That is the intentional vulnerability: once you can sign tokens, you control the claims.


