#!/usr/bin/env python3
"""
The Intercepted Message - CRYPTO-01-EASY
Two-part encryption: Caesar hint + AES encrypted payload
"""

import sys
import os
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import base64

def caesar_encrypt(text, shift):
    """Apply Caesar cipher with given shift"""
    result = []
    for char in text:
        if char.isupper():
            result.append(chr((ord(char) - 65 + shift) % 26 + 65))
        elif char.islower():
            result.append(chr((ord(char) - 97 + shift) % 26 + 97))
        else:
            result.append(char)
    return ''.join(result)

def aes_encrypt(plaintext, key):
    """AES encryption in CBC mode"""
    # Derive a 32-byte key from the given key using SHA256
    aes_key = hashlib.sha256(key.encode()).digest()
    
    # Use a fixed IV for this challenge (deterministic)
    iv = b'1337HEIST1337IV!'  # 16 bytes
    
    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(plaintext.encode(), AES.block_size))
    
    return base64.b64encode(ciphertext).decode()

def main():
    # Get the challenge key from environment (generated by startup.sh)
    if 'CHALLENGE_KEY' in os.environ:
        challenge_key = os.environ['CHALLENGE_KEY']
    else:
        challenge_key = "offline-default-crypto01"
    
    # Separate flag for this challenge
    flag = "TDHCTF{intercepted_comms_decrypted}"
    
    # Generate AES key from first part of challenge key
    aes_key = "HEIST" + challenge_key[:3]  # Pattern: HEIST + first 3 chars
    
    # Step 1: AES encrypt the key and flag
    payload = f"Key: {challenge_key}\nFlag: {flag}"
    aes_encrypted_payload = aes_encrypt(payload, aes_key)
    
    # Step 2: Create a message that contains the AES encrypted data
    # Include a small hint about the AES key
    message = f"""=== INTERCEPTED TRANSMISSION ===
FROM: UNKNOWN OPERATIVE
TO: HEIST COORDINATOR
STATUS: ENCRYPTED

MESSAGE:
The payload has been secured using AES-256-CBC encryption.
The decryption key follows our standard protocol: operation codename + first three characters of the session identifier.
IV used: 1337HEIST1337IV!

ENCRYPTED PAYLOAD:
{aes_encrypted_payload}

END TRANSMISSION"""
    
    # Step 3: Caesar shift the ENTIRE message (including the encrypted data)
    caesar_shift = 13  # ROT13
    encrypted_message = caesar_encrypt(message, caesar_shift)
    
    # Write output file
    output_path = '/challenge-files/crypto-01-intercepted-comms/intercepted_message.txt'
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w') as f:
        f.write(encrypted_message)
    
    print(f"[+] Challenge file generated: {output_path}")
    print(f"[+] AES Key: {aes_key} (HEIST + first 3 chars)")
    print(f"[+] Caesar shift: {caesar_shift}")
    print(f"[+] Challenge Key: {challenge_key}")
    print(f"[+] Flag: {flag}")

if __name__ == '__main__':
    main()

