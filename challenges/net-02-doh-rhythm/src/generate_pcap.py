#!/usr/bin/env python3
"""
NET-02 generator (pure python, no deps).

Creates a PCAP with multiple TCP/443 flows that look like TLS.
One flow carries a length/timing side-channel:
- Client -> Server sends "TLS Application Data" records with lengths encoding Base32 symbols.
- Inter-record timing buckets add a second factor (stream selection + alignment).

Players should not be able to decrypt payload. They recover the flag from metadata only.

Output:
  challenge-files/net-02-doh-rhythm/net-02-doh-rhythm.pcap
  challenge-files/net-02-doh-rhythm/README.txt
"""

from __future__ import annotations

import base64
import os
import random
import struct
import time
from dataclasses import dataclass
from ipaddress import IPv4Address


def _u16(x: int) -> int:
    return x & 0xFFFF


def _u32(x: int) -> int:
    return x & 0xFFFFFFFF


def checksum16(data: bytes) -> int:
    if len(data) % 2:
        data += b"\x00"
    s = 0
    for i in range(0, len(data), 2):
        s += (data[i] << 8) + data[i + 1]
        s = (s & 0xFFFF) + (s >> 16)
    return (~s) & 0xFFFF


def ipv4_bytes(ip: str) -> bytes:
    return int(IPv4Address(ip)).to_bytes(4, "big")


def build_ipv4(payload: bytes, src: str, dst: str, proto: int, ident: int, ttl: int = 64) -> bytes:
    ver_ihl = (4 << 4) | 5
    tos = 0
    total_len = 20 + len(payload)
    flags_frag = 0
    hdr = struct.pack(
        "!BBHHHBBH4s4s",
        ver_ihl,
        tos,
        total_len,
        _u16(ident),
        flags_frag,
        ttl,
        proto,
        0,
        ipv4_bytes(src),
        ipv4_bytes(dst),
    )
    csum = checksum16(hdr)
    hdr = hdr[:10] + struct.pack("!H", csum) + hdr[12:]
    return hdr + payload


def tcp_checksum_ipv4(src: str, dst: str, tcp_seg: bytes) -> int:
    pseudo = ipv4_bytes(src) + ipv4_bytes(dst) + struct.pack("!BBH", 0, 6, len(tcp_seg))
    return checksum16(pseudo + tcp_seg)


def build_tcp(
    payload: bytes,
    src_ip: str,
    dst_ip: str,
    sport: int,
    dport: int,
    seq: int,
    ack: int,
    flags: int,
    window: int,
) -> bytes:
    data_offset = 5
    off_flags = (data_offset << 12) | (flags & 0x01FF)
    hdr = struct.pack("!HHIIHHHH", sport, dport, _u32(seq), _u32(ack), off_flags, _u16(window), 0, 0)
    seg = hdr + payload
    csum = tcp_checksum_ipv4(src_ip, dst_ip, seg)
    hdr = hdr[:16] + struct.pack("!H", csum) + hdr[18:]
    return hdr + payload


PCAP_GLOBAL = struct.pack(
    "<IHHIIII",
    0xA1B2C3D4,
    2,
    4,
    0,
    0,
    65535,
    1,  # LINKTYPE_ETHERNET
)


def pcap_pkt(ts_sec: int, ts_usec: int, frame: bytes) -> bytes:
    incl = len(frame)
    return struct.pack("<IIII", ts_sec, ts_usec, incl, incl) + frame


def mac_bytes(mac: str) -> bytes:
    return bytes(int(b, 16) for b in mac.split(":"))


def build_ether(payload: bytes, src: str, dst: str, ethertype: int) -> bytes:
    return mac_bytes(dst) + mac_bytes(src) + struct.pack("!H", ethertype) + payload


@dataclass
class Frame:
    ts_us: int
    data: bytes


def tls_appdata_record(record_len: int) -> bytes:
    # TLS record header (content_type=0x17 appdata, version=0x0303, length=record_len)
    hdr = struct.pack("!BHH", 0x17, 0x0303, _u16(record_len))
    return hdr + os.urandom(record_len)


BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"


def main() -> None:
    random.seed(424242)

    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))
    out_dir = os.path.join(repo_root, "challenge-files", "net-02-doh-rhythm")
    os.makedirs(out_dir, exist_ok=True)

    # Flag matches Tasks.md placeholder.
    flag = "TDHCTF{dns_tunnel_key}"

    # Per-deployment challenge key (generated by startup.sh). Players must recover this from the PCAP too.
    # Priority: env CHALLENGE_KEY > keys/net-02-doh-rhythm.key > keys/net-02.key > fallback.
    challenge_key = os.environ.get("CHALLENGE_KEY", "").strip()
    if not challenge_key:
        for cand in ("net-02-doh-rhythm.key", "net-02.key"):
            p = os.path.join(repo_root, "keys", cand)
            if os.path.exists(p):
                with open(p, "r", encoding="utf-8", errors="ignore") as fh:
                    challenge_key = fh.read().strip()
                break
    if not challenge_key:
        challenge_key = "offline-session-key"

    message = f"KEY:{challenge_key}\nFLAG:{flag}\n".encode("utf-8")

    # Encode into Base32 (no padding, uppercase)
    b32 = base64.b32encode(message).decode("ascii").rstrip("=")

    # Real flow (the "signal")
    c_ip = "10.13.37.10"
    s_ip = "10.13.37.53"
    c_port = 51022
    s_port = 443

    # Decoy flows (noise) — generate a larger set to make the capture heavy.
    decoys: list[tuple[str, str, int, int]] = []
    for i in range(11, 31):  # 20 decoy clients
        decoys.append((f"10.13.37.{i}", "10.13.37.53", 51000 + i, 443))

    mac_src = "02:42:ac:11:00:10"
    mac_dst = "02:42:ac:11:00:11"

    frames: list[Frame] = []
    t0 = int(time.time())
    now_us = t0 * 1_000_000

    # Background non-TLS-ish noise (still inside Ethernet/IPv4):
    # - extra UDP "DNS-like" packets on port 53
    # - random TCP packets to common ports (80/22/8080) to distract filters
    def emit_background_noise(count: int) -> None:
        nonlocal now_us
        for _ in range(count):
            src_ip = f"10.13.{random.randrange(0, 50)}.{random.randrange(2, 254)}"
            dst_ip = f"10.13.{random.randrange(0, 50)}.{random.randrange(2, 254)}"
            if random.random() < 0.6:
                # UDP (DNS-ish): craft a minimal UDP header + payload; checksum omitted (fine for offline noise)
                sport = random.randrange(1024, 65535)
                dport = random.choice([53, 53, 123, 161, 514, random.randrange(1, 65535)])
                payload = os.urandom(random.randrange(18, 220))
                udp_len = 8 + len(payload)
                udp = struct.pack("!HHHH", sport, dport, udp_len, 0) + payload
                ip = build_ipv4(udp, src_ip, dst_ip, proto=17, ident=random.randrange(0, 65536), ttl=random.choice([52, 64, 127]))
            else:
                # TCP (non-TLS): random payload, mostly ACK/PSH
                sport = random.randrange(1024, 65535)
                dport = random.choice([22, 80, 8080, 31337, random.randrange(1, 65535)])
                payload = os.urandom(random.randrange(0, 300))
                seq = random.randrange(0, 2**32)
                ack = random.randrange(0, 2**32)
                off_flags = (5 << 12) | random.choice([0x10, 0x18, 0x11])
                tcp = struct.pack("!HHIIHHHH", sport, dport, seq, ack, off_flags, 4096, 0, 0) + payload
                ip = build_ipv4(tcp, src_ip, dst_ip, proto=6, ident=random.randrange(0, 65536), ttl=random.choice([45, 59, 64]))
            frames.append(Frame(now_us + random.randrange(0, 2_400_000), build_ether(ip, mac_src, mac_dst, 0x0800)))

    emit_background_noise(4500)

    def emit_flow_tuple(src_ip: str, dst_ip: str, sport: int, dport: int, payloads: list[tuple[str, bytes, int]]):
        nonlocal now_us
        seq_c = 1000 + random.randrange(0, 5000)
        seq_s = 7000 + random.randrange(0, 5000)

        # 3-way handshake
        syn = build_tcp(b"", src_ip, dst_ip, sport, dport, seq_c, 0, flags=0x02, window=64240)
        ip = build_ipv4(syn, src_ip, dst_ip, proto=6, ident=random.randrange(0, 65536), ttl=64)
        frames.append(Frame(now_us, build_ether(ip, mac_src, mac_dst, 0x0800)))
        now_us += 5_000

        synack = build_tcp(b"", dst_ip, src_ip, dport, sport, seq_s, seq_c + 1, flags=0x12, window=64240)
        ip = build_ipv4(synack, dst_ip, src_ip, proto=6, ident=random.randrange(0, 65536), ttl=64)
        frames.append(Frame(now_us, build_ether(ip, mac_dst, mac_src, 0x0800)))
        now_us += 5_000

        ack = build_tcp(b"", src_ip, dst_ip, sport, dport, seq_c + 1, seq_s + 1, flags=0x10, window=64240)
        ip = build_ipv4(ack, src_ip, dst_ip, proto=6, ident=random.randrange(0, 65536), ttl=64)
        frames.append(Frame(now_us, build_ether(ip, mac_src, mac_dst, 0x0800)))
        now_us += 10_000

        seq_c += 1
        seq_s += 1

        # Application bursts (client->server)
        for direction, rec, gap_us in payloads:
            now_us += gap_us
            if direction == "c2s":
                seg = build_tcp(rec, src_ip, dst_ip, sport, dport, seq_c, seq_s, flags=0x18, window=64240)
                seq_c = (seq_c + len(rec)) & 0xFFFFFFFF
                ip = build_ipv4(seg, src_ip, dst_ip, proto=6, ident=random.randrange(0, 65536), ttl=64)
                frames.append(Frame(now_us, build_ether(ip, mac_src, mac_dst, 0x0800)))
            else:
                seg = build_tcp(rec, dst_ip, src_ip, dport, sport, seq_s, seq_c, flags=0x18, window=64240)
                seq_s = (seq_s + len(rec)) & 0xFFFFFFFF
                ip = build_ipv4(seg, dst_ip, src_ip, proto=6, ident=random.randrange(0, 65536), ttl=64)
                frames.append(Frame(now_us, build_ether(ip, mac_dst, mac_src, 0x0800)))

    # Build signal payloads:
    # Encoding rule:
    # - For each Base32 char X, map value v (0..31)
    # - Client sends TLS appdata record where record_len = 480 + (v*7)
    # - Gap bucket between records is either 20ms or 45ms depending on parity of v (alignment aid)
    signal_payloads: list[tuple[str, bytes, int]] = []
    for ch in b32:
        v = BASE32_ALPHABET.index(ch)
        rlen = 480 + (v * 7)
        gap = 20_000 if (v % 2 == 0) else 45_000
        signal_payloads.append(("c2s", tls_appdata_record(rlen), gap))
        # Add server noise response (random-ish)
        if random.random() < 0.6:
            signal_payloads.append(("s2c", tls_appdata_record(random.choice([97, 133, 211, 389])), random.choice([7_000, 11_000, 19_000])))

    # Add prelude and tail noise (signal flow)
    for _ in range(10):
        signal_payloads.insert(0, ("c2s", tls_appdata_record(random.choice([512, 517, 519])), random.choice([12_000, 18_000])))
    for _ in range(9):
        signal_payloads.append(("c2s", tls_appdata_record(random.choice([600, 777, 888])), random.choice([15_000, 30_000])))

    emit_flow_tuple(c_ip, s_ip, c_port, s_port, signal_payloads)

    # Decoy flows: similar-looking TLS records but lengths not following the encoding rule.
    # Make these big to slow down “just eyeball it” approaches.
    for dip, sip, dp, sp in decoys:
        payloads: list[tuple[str, bytes, int]] = []
        for _ in range(random.randint(80, 150)):
            payloads.append(("c2s", tls_appdata_record(random.randint(200, 1200)), random.randint(5_000, 60_000)))
            if random.random() < 0.7:
                payloads.append(("s2c", tls_appdata_record(random.randint(50, 600)), random.randint(3_000, 25_000)))
        emit_flow_tuple(dip, sip, dp, sp, payloads)

    # Shuffle a bit but keep rough time order (still solvable by flow selection + parsing)
    frames.sort(key=lambda fr: fr.ts_us)
    # Add micro-jitter to make simple "fixed interval" assumptions fail
    jittered: list[Frame] = []
    for fr in frames:
        jittered.append(Frame(fr.ts_us + random.randrange(0, 2_000), fr.data))

    out_pcap = os.path.join(out_dir, "net-02-doh-rhythm.pcap")
    with open(out_pcap, "wb") as f:
        f.write(PCAP_GLOBAL)
        for fr in jittered:
            ts_sec = fr.ts_us // 1_000_000
            ts_usec = fr.ts_us % 1_000_000
            f.write(pcap_pkt(int(ts_sec), int(ts_usec), fr.data))

    out_readme = os.path.join(out_dir, "README.txt")
    with open(out_readme, "w", encoding="utf-8") as f:
        f.write(
            "=== NET-02: DoH Rhythm — Metadata Exfil ===\n\n"
            "You captured internal traffic to a 'DoH gateway'. Everything is encrypted.\n"
            "The Directorate still leaked the key via metadata.\n\n"
            "Files:\n"
            "- net-02-doh-rhythm.pcap\n\n"
            "Objective:\n"
            "- Recover BOTH values hidden in the capture:\n"
            "  - KEY: <challenge key>\n"
            "  - FLAG: TDHCTF{...}\n\n"
            "Notes:\n"
            "- Decryption is not required and not possible from this capture.\n"
            "- Focus on metadata: sizes, timing, patterns.\n"
        )

    print(f"[+] Wrote {out_pcap}")
    print(f"[+] Wrote {out_readme}")


if __name__ == "__main__":
    main()


